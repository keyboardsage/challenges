| Number     |     Name      | Difficulty  | Language | Filename | Notes/Hint  |
| ---------- | ------------- | ----------- | -------- | -------- | ----------- |
| 2667 | Create Hello World Function   | Easy | JavaScript | 2667_create_hello_world_function.js         | You have a function within a function; understand how closures work. Another approach, just return a function using the ES6 arrow operator. That said, simply returning a string or string literal from the nested function will work here too. |
| 2620 | Counter                       | Easy | JavaScript | 2620_counter.js         | If you understood closures from the first question. Then you should notice that the function returns a function; its actually that inner function, which has access to the outer function's variables that gets run. The outer variable always exists for the nested/closure function. |
| 2704 | To Be Or Not To Be            | Easy | JavaScript | 2704_to_be_or_not_to_be.js         | On the surface, the prompt appears to request that the `expect` function differ based upon the chained subsequent call; but that is impossible, because there is no way to know what subsequent call will be made in the future. The better interpretation/perspective of the question is, the function `expect` returns an object, period! Now, within that object there are two function objects, one called `toBe` and one called `notToBe`. The caller can then use that object to make whatever additional call(s) they like. The true goal of this question was to make it clear to you how chaining can be implemented in JavaScript.
| 2665 | Closures                      | Easy | JavaScript | 2665_counter_ii.js         | This just makes sure you can put together the concept of chaining using a returned object, closure's outer scoped variables being accessible, and the consequences of altering/not altering a variable for a chain.