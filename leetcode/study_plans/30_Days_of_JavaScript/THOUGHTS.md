| Number     |     Name      | Difficulty  | Language | Filename | Notes/Hint  |
| ---------- | ------------- | ----------- | -------- | -------- | ----------- |
| 2667 | Create Hello World Function   | Easy | JavaScript | 2667_create_hello_world_function.js         | You have a function within a function; understand how closures work. Another approach, just return a function using the ES6 arrow operator. That said, simply returning a string or string literal from the nested function will work here too. |
| 2620 | Counter                       | Easy | JavaScript | 2620_counter.js         | If you understood closures from the first question. Then you should notice that the function returns a function; its actually that inner function, which has access to the outer function's variables that gets run. The outer variable always exists for the nested/closure function. |
| 2704 | To Be Or Not To Be            | Easy | JavaScript | 2704_to_be_or_not_to_be.js         | On the surface, the prompt appears to request that the `expect` function differ based upon the chained subsequent call; but that is impossible, because there is no way to know what subsequent call will be made in the future. The better interpretation/perspective of the question is, the function `expect` returns an object, period! Now, within that object there are two function objects, one called `toBe` and one called `notToBe`. The caller can then use that object to make whatever additional call(s) they like. The true goal of this question was to make it clear to you how chaining can be implemented in JavaScript.
| 2665 | Closures                      | Easy | JavaScript | 2665_counter_ii.js         | This just makes sure you can put together the concept of chaining using a returned object, closure's outer scoped variables being accessible, and the consequences of altering/not altering a variable for a chain.
| 2635 | Apply Transform Over Each Element in Array | Easy | JavaScript | 2635_apply_transform_over_each_element_in_array.js         | Understand what `map` (`Array.map` in JS) does. Something of note here, most languages would require an if-statement, variadic function, default parameter value, etc. because the callback function may have 1 or 2 values. However, JS just ignores extra paramters by setting them to `undefined`, so you can just call `fn` once with parameters, and if the index value is unnecessary, the callback function will simply drop it if the callback only used one parameter. Lastly, `map` generally returns a new array for safety reasons. Suppose you decide to save on space complexity by altering the original array in-place just keep in mind that if the mapped function generates incorrect input data then there would be no way to undo that because the input data is lost/altered. I wrote my code in-place but its good to be aware of the consequences.
| 2634 | Filter Elements from Array    | Easy | JavaScript | 2634_filter_elements_from_array.js         | The `map` function is used commonly, filter less so in my experience. However, I see its usefulness. Rather than doing hackish things with `map` or walking the array once to mark and a second time to prune; the `filter` can prune elements based on the truthiness of a callback function you provide.
| 2626 | Array Reduce Transformation   | Easy | JavaScript | 2626_array_reduce_transformation.js         | The `reduce` function is usually used as heavily as `map` in my experience and its straight forward, apply the transformation, and apply the next one based upon the last one. Again, keep in mind, I implemented this in-place just as I did with `map` and `filter` because it solves the problem.
| 2629 | Function Composition          | Easy | JavaScript | 2629_function_composition.js         | If you decide to use the `in` keyword, just keep in mind that object keys are treated as strings in JavaScript, even if they represent numeric indices.
| 2703 | Return Length of Arguments Passed   | Easy | JavaScript | 2703_return_length_of_arguments_passed.js         | Just trying to ensure that you are aware `arguments.length` exists in the language and what it means.
| 2666 | Allow One Function Call       | Easy | JavaScript | 2666_allow_one_function_call.js         | Fundamentally this is just the use of closures again. However, it does also make you aware of the `...` spead operator.
| 2623 | Memoize                       | Medium | JavaScript | 2623_memoize.js         | Classic dynamic programming problem, optimizing the function by avoiding operations that have previously been computed. In this case, if you used an array as a structure for caching inputs-to-answers you could end up adding lots of empty indices; so a linked list or dictionary/map would be better. Javascript treats objects as dictionaries, so use an object. The keys have to be unique though, so you have to use a function that ensures that; I chose JSON.stringify.
| 2723 | Add Two Promises              | Easy | JavaScript | 2723_add_two_promises.js         | Rather than using Promises, async and await allows a person to use Promises implicitly and with ease. When filling out the asynchronous function you need to get the resolved answer from both the promises passed in. You can either do that sequentially by calling each promise's resolve using await, or you can apply await to `Promise.all` which will run them both concurrently.
| 2621 | Sleep                         | Easy | JavaScript | 2621_sleep.js         | A Promise can chain using `then`. This question just wants to ensure you know how to make a Promise. An async function tends to return a Promise.
| 2715 | Timeout Cancellation          | Easy | JavaScript | 2715_timeout_cancellation.js         | What this question does is ensure you know how to set a timeout and then unset that timeout. Additionally, it makes sure you know the difference between defining a function and actually executing that function. Lastly, it cements the fact that just like the momoize function, its possible in JS to give an existing function "characteristics" (make memoize data, make it on a timer, etc.) by wrapping them in another function.
| 2725 | Timeout Interval              | Easy | JavaScript | 2725_timeout_interval.js         | Originally, this question makes you think, hmm, maybe I need to use a Promise, closures, and `setTimeout` creatively to make a timer. However, there is a `setInterval` function.
| 2637 | Promise Time Limit            | Medium | JavaScript | 2637_promise_time_limit.js         | Fundamentally, what this question is asking is, run fn, but if it takes longer than t seconds to run, return a reject message. The immediate solution is to return a promise that starts off with `setTimeout`; and have the timeout invoke reject after t seconds. Then chain the fn using `then` to propogate it's return upward, this ensures your values match fn's return values, like so, `fn(...args).then(resolve, reject)`. However, `Promise.race` provides the same semantics in a more elegant way and its a preferable approach imo.
| 2622 | Cache with time limit         | Medium | JavaScript | 2622_cache_with_time_limit.js         | Primarily, the trick is to remember that the data structure you use as a cache, be it an array, set, map, object, etc. can always have another object as a value; and this is important because you need to store not only a value but also a reference to the object `setTimeout` returns. Naturally, you could have a second data structure for timers, but that adds complication. Also, this drives home the point that setTimeout is asynchronous/non-blocking when called.
| 2627 | Debounce                      | Medium | JavaScript | 2627_debounce.js         | This is delightfully simple to implement, but it doesn't seem so if you don't realize timeout functions are what you need. You could waste a lot of time if you think you need Date.now().
| 2721 | Execute Asynchronous Functions in Parallel | Medium | JavaScript | 2721_execute_asynchronous_functions_in_parallel.js         | This was only medium, but it felt like a hard. The solution has to built up in pieces imo. First, you need a for-loop structure that alters an array by storing the returned values from the functions stored in `functions`. And the explanation said return a Promise, so you know to do that. The loop needs to complete before returning, so the Promise is prefixed with await and the `promiseAll` is prefixed with async. Lastly, the `catch` has to be added, so the first fail gets returned.