| Number     |     Name      | Difficulty  | Language | Filename | Notes/Hint  |
| ---------- | ------------- | ----------- | -------- | -------- | ----------- |
| 2667 | Create Hello World Function   | Easy | JavaScript | 2667_create_hello_world_function.js         | You have a function within a function; understand how closures work. Another approach, just return a function using the ES6 arrow operator. That said, simply returning a string or string literal from the nested function will work here too. |
| 2620 | Counter                       | Easy | JavaScript | 2620_counter.js         | If you understood closures from the first question. Then you should notice that the function returns a function; its actually that inner function, which has access to the outer function's variables that gets run. The outer variable always exists for the nested/closure function. |
| 2704 | To Be Or Not To Be            | Easy | JavaScript | 2704_to_be_or_not_to_be.js         | On the surface, the prompt appears to request that the `expect` function differ based upon the chained subsequent call; but that is impossible, because there is no way to know what subsequent call will be made in the future. The better interpretation/perspective of the question is, the function `expect` returns an object, period! Now, within that object there are two function objects, one called `toBe` and one called `notToBe`. The caller can then use that object to make whatever additional call(s) they like. The true goal of this question was to make it clear to you how chaining can be implemented in JavaScript.
| 2665 | Closures                      | Easy | JavaScript | 2665_counter_ii.js         | This just makes sure you can put together the concept of chaining using a returned object, closure's outer scoped variables being accessible, and the consequences of altering/not altering a variable for a chain.
| 2635 | Apply Transform Over Each Element in Array | Easy | JavaScript | 2635_apply_transform_over_each_element_in_array.js         | Understand what `map` (`Array.map` in JS) does. Something of note here, most languages would require an if-statement, variadic function, default parameter value, etc. because the callback function may have 1 or 2 values. However, JS just ignores extra paramters by setting them to `undefined`, so you can just call `fn` once with parameters, and if the index value is unnecessary, the callback function will simply drop it if the callback only used one parameter. Lastly, `map` generally returns a new array for safety reasons. Suppose you decide to save on space complexity by altering the original array in-place just keep in mind that if the mapped function generates incorrect input data then there would be no way to undo that because the input data is lost/altered. I wrote my code in-place but its good to be aware of the consequences.
| 2634 | Filter Elements from Array    | Easy | JavaScript | 2634_filter_elements_from_array.js         | The `map` function is used commonly, filter less so in my experience. However, I see its usefulness. Rather than doing hackish things with `map` or walking the array once to mark and a second time to prune; the `filter` can prune elements based on the truthiness of a callback function you provide.
| 2626 | Array Reduce Transformation   | Easy | JavaScript | 2626_array_reduce_transformation.js         | The `reduce` function is usually used as heavily as `map` in my experience and its straight forward, apply the transformation, and apply the next one based upon the last one. Again, keep in mind, I implemented this in-place just as I did with `map` and `filter` because it solves the problem.