| Number     |     Name      | Difficulty  | Language | Filename | Notes/Hint  |
| ---------- | ------------- | ----------- | -------- | -------- | ----------- |
| 1    | Two Sums                      | Easy | C | 1_two_sums.c                         | Don't compare indices already compared.  |
| 7    | Reverse Integer               | Medium | C | 7_reverse_integer.c                  | The ideal solution is to follow a process akin to #504 Base 7. An alternative approach is to create an `itoa` function and then use a process akin to #344 Reverse String. The key concern in this problem is that an `int` is too small to hold values outside of -2^31 or 2^31-1. So `long long int` is sufficiently large to hold numbers outside of the 32-bit integer range in a 32-bit environment. It can be utilized for holding/validating numbers. For example, `atoll` will not overflow like `atoi`. |
| 9    | Palindrome Number             | Easy | C | 9_palindrome_number.c                | Convert half the palindrome to base 10 and compare it to the remaining half. |
| 14   | Longest Common Prefix         | Easy | C | 14_longest_common_prefix.c           | Compare each character of an arbitrarily chosen word one-by-one against all words adn keep the characters that all the words have in common. |
| 17   | Letter Combinations of a Phone Number | Medium | C | 17_letter_combinations_of_a_phone_number.c           | Iteration is difficult since the number of digits can vary. Recursion seems easier. If you think of recursion as a tree, then the answer is known at the leaves in a recursive void function. |
| 20   | Valid Parentheses             | Easy | C | 20_Valid_Parenthesis.c               | Use a stack. Increment on open and decrement on close. |
| 104  | Maximum Depth of Binary Tree          | Easy | C | 104_maximum_depth_of_binary_tree.c    | DFS looks a little different when applied to a binary tree that uses nodes rather than a graph that uses an adjacency matrix. |
| 344  | Reverse String                | Easy | C | 344_reverse_string.c                 | Iterate for half the word length, swapping characters. |
| 463  | Island Perimeter              | Easy | C | 463_island_perimeter.c               | It may not appear to be at first, but this can be solved with a DFS. A DFS fundamentally tallies a visit to prevent loops, and visits each neighbor. A neighbor is simply a tile with land. |
| 504  | Base 7                        | Easy | C | 504_base_7.c                         | Base conversion is just a division, modulus, and accumulator. Division and Modulo use the new radix. The accumulator uses the old radix. |
| 1009 | Complement of Base 10 Integer | Easy | C | 1009_complement_of_base_10_integer.c | The binary complement of the signed input produces a negative signed output. You must inverse the integer and also disregard the sign bits. Return the "unsigned"/value portion only. |
| 1380 | Lucky Numbers in a Matrix     | Easy | C | 1380_lucky_numbers_in_a_matrix.c         | No special tricks. |
| 1572 | Matrix Diagonal Sum           | Easy | C | 1572_matrix_diagonal_sum.c | No special tricks. Simple, just busy work. |
| 1837 | Sum of Digits in Base K       | Easy | C | 1837_sum_of_digits_in_base_k.c       | Same principles as #504 but the accumulator is only a summation of the one's place. |